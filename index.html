<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>US States Map with Electoral Votes</title>
    <style>
      body {
        background-color: rgba(218, 218, 218, 0.653);
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      text {
        font-family: Arial, Helvetica, sans-serif;
      }

      header {
        text-align: center;
        padding: 20px;
        background-color: #292929;
        width: 100%;
      }

      h1 {
        font-family: Arial, Helvetica, sans-serif;
        font-size: 36px;
        margin: 0;
        color: white;
      }

      #content {
        display: flex;
        width: 100%;
      }

      .state {
        fill: rgb(255, 255, 255);
        stroke: rgb(213, 213, 213);
        stroke-width: 1px;
      }

      .state:hover {
        fill: rgb(254, 251, 184);
      }

      .state.highlighted {
        fill: rgb(241, 241, 186);
      }

      .vote-circle {
        fill: rgb(0, 0, 0);
        opacity: .7;
        stroke: none;
        pointer-events: none;
      }

      .vote-circle.highlighted {
        fill: rgb(190, 26, 255);
      }

    .state-initials {
        font-size: 10px;
        font-family: Arial, Helvetica, sans-serif;
        font-weight: bold;
        text-anchor: bottom;
        pointer-events: none;
      }

      #stateList {
      width: 200px;
      padding-right: 20px;
      box-sizing: border-box;
    }

    #mapContainer {
      flex: 1;
    }

    .state-row {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
      font-size: 8px;
      font-family: Arial, Helvetica, sans-serif;
    }

    .radio-container {
      display: flex;
      align-items: center;
    }

    .radio-container label {
      /* margin-left: 5px; */
      margin-right: 10px;
      font-size: 8px;
    }

    .radio-container input[type="radio"] {
      transform: scale(0.8);
    }

      #stateList {
        width: 150px;
        padding-right: 10px;
        box-sizing: border-box;
      }

      #buttonContainer {
        display: block;
        margin: 20px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Electoral College Vote Map</h1>
    </header>
    <div id="content">
      <div style="display: flex;">
        <div id="stateList"></div>
        <div id="mapContainer">
          <div id="buttonContainer">
            <button id="downloadMapButton">Download Map</button>
            <button id="downloadChartButton">Download Chart</button>
          </div>
          <div id="barChart"></div>
          <div id="map"></div>
          <!-- <svg width="960" height="600"></svg> -->
        </div>
      </div>
    </div>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script>
      const width = 800;
      const height = 500;
      const circleRadius = 2;
      const circlesPerRow = 4;

      const mapContainer = d3.select("#map");

      const svg = mapContainer
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const projection = d3.geoAlbersUsa()
        .scale(1000)
        .translate([width / 2, height / 2]);

      const path = d3.geoPath()
        .projection(projection);

      d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json")
        .then(topoData => {
          const states = topojson.feature(topoData, topoData.objects.states);

          // Filter out U.S. territories
        const filteredStates = states.features.filter(state => {
          const stateName = state.properties.name;
          return stateName !== 'Puerto Rico' && stateName !== 'Guam' && stateName !== 'United States Virgin Islands' && stateName !== 'American Samoa' && stateName !== 'Commonwealth of the Northern Mariana Islands';
        });

        d3.json("electoral-college-votes.json")
        .then(electoralData => {
            filteredStates.forEach(state => {
            const stateData = electoralData.find(d => d.state === state.properties.name);
            if (stateData) {
                state.properties.electoral_votes = stateData.electoral_votes;
                state.properties.postal = stateData.postal;
            }
        });

        // console.log(filteredStates)

          const statesPaths = svg.selectAll(".state")
            .data(states.features)
            .enter()
            .append("path")
            .attr("class", "state")
            .attr("fill", 'white') //make explicit for download
            .attr("d", path)
            .append("title")
            .text(d => `${d.properties.name}: ${d.properties.electoral_votes} electoral votes`);

            // Add state initials
            svg.selectAll(".state-initials")
            .data(states.features)
            .enter()
            .append("text")
            .attr("class", "state-initials")
            .attr("x", d => path.centroid(d)[0])
            .attr("y", d => path.centroid(d)[1])
            .text(d => `${d.properties.postal}`);
            // .text("BB")

            const voteCircles = svg.selectAll(".vote-circle")
              .data(states.features)
              .enter()
              .append("g")
              .attr("class", "vote-circle")
              .attr("state-name", d => d.properties.name)
              .attr("transform", d => `translate(${path.centroid(d)})`);

            voteCircles.selectAll(".vote-circle")
              .data(d => {
                const votes = d.properties.electoral_votes;
                const positions = [];
                const circleSpacing = circleRadius * 2.5;
                let x = -circleSpacing * 2;
                let y = -circleSpacing * 2;
                let row = 0;
                let col = 0;

                for (let i = 0; i < votes; i++) {
                  positions.push([x, y]);
                  col++;

                  if (col === circlesPerRow) {
                    col = 0;
                    row++;
                    x = -circleSpacing * 2;
                    y += circleSpacing;
                  } else {
                    x += circleSpacing;
                  }
                }

                return positions;
              })
              .enter()
              .append("circle")
              .attr("class", "vote-circle")
              .attr("r", circleRadius)
              .attr("cx", d => d[0])
              .attr("cy", d => d[1]);

              // Add mouseover and mouseout event listeners after voteCircles is defined
              statesPaths
                  .on("mouseover", function(event, d) {
                      const stateName = d.properties.name;
                      d3.select(this).classed("highlighted", true);
                      voteCircles.selectAll("circle")
                      .classed("highlighted", function() {
                          return d3.select(this.parentNode).attr("state-name") === stateName;
                      });
                  })
                  .on("mouseout", function() {
                      d3.select(this).classed("highlighted", false);
                      voteCircles.selectAll("circle")
                      .classed("highlighted", false);
                  });

            });



          // Generate the state list with radio buttons
          const stateList = d3.select("#stateList");
          const demColor = "#467bf7"
          const repColor = "#ff7575"

          // Sort the states alphabetically by name
          // const sortedStates = filteredStates.sort((a, b) => a.properties.name.localeCompare(b.properties.name));

          // console.log(sortedStates)

          filteredStates.forEach(state => {
            console.log(state.properties) //error here somewhere - it can't read property other than name
            const stateName = state.properties.name;
            const postal = state.properties.postal;
            const stateRow = stateList.append("div").attr("class", "state-row");

            const radioContainer = stateRow.append("div").attr("class", "radio-container");
            
            radioContainer.append("input")
              .attr("type", "radio")
              .attr("id", `${postal}-d`)
              .attr("name", postal) //try keeping name as label, but ID is postal?
              .on("change", function() {
                if (this.checked) {
                  updateStateColor(stateName, demColor);
                }
              });
            
            radioContainer.append("label")
              .attr("for", `${postal}-d`) 
              .text("D");
            
            radioContainer.append("input")
              .attr("type", "radio")
              .attr("name", postal)
              .attr("id", `${postal}-r`) 
              .on("change", function() {
                if (this.checked) {
                  updateStateColor(stateName, repColor);
                }
              });
            
            radioContainer.append("label")
              .attr("for", `${postal}-r`)
              .text("R");
            
            stateRow.append("span").text(stateName);
          });

          const barChartWidth = 500;
          const barChartHeight = 80;
          const barChartMargin = { top: 20, right: 20, bottom: 20, left: 40 };

          const barChart = d3.select("#barChart")
            .append("svg")
            .attr("width", barChartWidth)
            .attr("height", barChartHeight)
            .append("g")
            .attr("transform", `translate(${barChartMargin.left}, ${barChartMargin.top})`);

            const updateBarChart = () => {
              const dVotes = d3.sum(filteredStates, d => {
                const statePostal = d.properties.postal;
                const radio = d3.select(`#${statePostal}-d`).node();
                return radio && radio.checked ? d.properties.electoral_votes : 0;
              });

              const rVotes = d3.sum(filteredStates, d => {
                const statePostal = d.properties.postal;
                const radio = d3.select(`#${statePostal}-r`).node();
                return radio && radio.checked ? d.properties.electoral_votes : 0;
              });

          const barChartData = [
            { party: "D", votes: dVotes },
            { party: "R", votes: rVotes }
          ];

          const xScale = d3.scaleLinear()
          .domain([0, d3.max(barChartData, d => d.votes)])
          .range([0, barChartWidth - barChartMargin.left - barChartMargin.right]);

        const yScale = d3.scaleBand()
          .domain(barChartData.map(d => d.party))
          .range([0, barChartHeight - barChartMargin.top - barChartMargin.bottom])
          .padding(0.2);

        const barGroups = barChart.selectAll(".bar-group")
          .data(barChartData);

        barGroups.enter()
          .append("g")
          .attr("class", "bar-group")
          .merge(barGroups)
          .attr("transform", d => `translate(0, ${yScale(d.party)})`);

        barGroups.selectAll("rect")
          .data(d => [d])
          .enter()
          .append("rect")
          .merge(barGroups.selectAll("rect"))
          .attr("width", d => xScale(d.votes))
          .attr("height", yScale.bandwidth())
          .attr("fill", d => d.party === "D" ? demColor : repColor)
          .attr("rx", 4)
          .attr("ry", 4);

        barGroups.selectAll("text.party-label")
          .data(d => [d])
          .enter()
          .append("text")
          .attr("class", "party-label")
          .merge(barGroups.selectAll("text.party-label"))
          .attr("x", -10)
          .attr("y", yScale.bandwidth() / 2)
          .attr("text-anchor", "end")
          .attr("alignment-baseline", "middle")
          .style("font-size", "12px")
          .text(d => d.party);

        barGroups.selectAll("text.vote-count")
          .data(d => [d])
          .enter()
          .append("text")
          .attr("class", "vote-count")
          .merge(barGroups.selectAll("text.vote-count"))
          .attr("x", d => xScale(d.votes) - 10)
          .attr("y", yScale.bandwidth() / 2)
          .attr("text-anchor", "end")
          .attr("alignment-baseline", "middle")
          .style("font-size", "12px")
          .text(d => d.votes);
      };
      

        // Update the updateStateColor function to call updateBarChart
        function updateStateColor(stateName, color) {
          svg.selectAll(".state")
            .filter(d => d.properties.name === stateName)
            .style("fill", color);

          updateBarChart();
        }
        });

        function downloadMapSVG() {
            const svgElement = document.querySelector("#map svg");

            // Create a deep clone of the SVG element
            const clonedSvgElement = svgElement.cloneNode(true);

            // Remove the tooltip element from the cloned SVG
            const tooltipElement = clonedSvgElement.querySelector(".tooltip");
            if (tooltipElement) {
              tooltipElement.remove();
            }

            // Set the fill and stroke colors on the state paths and vote circles
            const statePaths = clonedSvgElement.querySelectorAll(".state");
            statePaths.forEach(path => {
              const fillColor = path.getAttribute("fill");
              const strokeColor = 'darkgrey';
              path.setAttribute("fill", fillColor);
              path.setAttribute("stroke", strokeColor);
            });

            const voteCircles = clonedSvgElement.querySelectorAll(".vote-circle circle");
            voteCircles.forEach(circle => {
              const fillColor = circle.getAttribute("fill");
              circle.setAttribute("fill", fillColor);
            });

            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(clonedSvgElement);
            const blob = new Blob([svgString], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);

            const link = document.createElement("a");
            link.href = url;
            link.download = "us-states-map.svg";
            link.click();

            URL.revokeObjectURL(url);
          }

      function downloadChartSVG() {
        const svgElement = document.querySelector("#barChart svg");

        // Create a deep clone of the SVG element
        const clonedSvgElement = svgElement.cloneNode(true);

        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(clonedSvgElement);
        const blob = new Blob([svgString], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.href = url;
        link.download = "bar-chart.svg";
        link.click();

        URL.revokeObjectURL(url);
      }

      const downloadMapButton = document.getElementById("downloadMapButton");
      downloadMapButton.addEventListener("click", downloadMapSVG);

      const downloadChartButton = document.getElementById("downloadChartButton");
      downloadChartButton.addEventListener("click", downloadChartSVG);
    </script>
  </body>
</html>